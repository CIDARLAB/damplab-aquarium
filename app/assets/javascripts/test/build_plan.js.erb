<% if Rails.env.development? %>

shark.use_succ_and_pred = function(name) {

  let plan = AQ.Plan.new_plan(name),
      assemble_type = AQ.OperationType.find_cached("Assemble Plasmid"),
      assemble = AQ.Operation.new_operation(assemble_type, 0, 160, 160),
      purify_type = AQ.OperationType.find_cached("Purify Gel Slice"),
      pcr_type = AQ.OperationType.find_cached("Make PCR Fragment");

  plan.operations.push(assemble);
  plan.add_wire_from(assemble.inputs[0], assemble, { operation_type: purify_type, output: purify_type.outputs[0]});
  plan.add_wire_to(assemble.outputs[0], assemble, { operation_type: pcr_type, input: pcr_type.inputs[2]});

  return plan;

}

shark.make_pcr_plan = function(sample, container) {

  let plan =      AQ.Plan.new_plan("PCR Plan Construction Test"),
      extract =   AQ.OperationType.find_cached("Extract Gel Slice").create(0, 160, 80),
      run =       AQ.OperationType.find_cached("Run Gel").create(0, 160, 160),
      pour =      AQ.OperationType.find_cached("Pour Gel").create(0, 360, 240),
      pcr =       AQ.OperationType.find_cached("Make PCR Fragment").create(0, 160, 240),
      rehydrate = AQ.OperationType.find_cached("Rehydrate Primer").create(0, 160, 320),
      order =     AQ.OperationType.find_cached("Order Primer").create(0, 160, 400);

  console.log(order)

  plan.operations = [ extract, run, pour, pcr, rehydrate, order ];

  plan.connect(order.output("Primer"),             order,     rehydrate.input("Primer"),   rehydrate);
  plan.connect(rehydrate.output("Primer Aliquot"), rehydrate, pcr.input("Forward Primer"), pcr);
  plan.connect(pcr.output("Fragment"),             pcr,       run.input("Fragment"),       run);  
  plan.connect(pour.output("Lane"),                pour,      run.input("Gel"),            run);  
  plan.connect(run.output("Fragment"),             run,       extract.input("Fragment"),   extract); 

  plan.equiv(rehydrate, rehydrate.input("Primer"), rehydrate, rehydrate.output("Primer Aliquot")).should.equal(true);
  plan.equiv(pcr, pcr.output("Fragment"), rehydrate, rehydrate.output("Primer Aliquot")).should.equal(false);
  plan.equiv(run, run.output("Fragment"), extract, extract.input("Fragment")).should.equal(true);

  plan.classes().length.should.equal(6)

  return Promise
     .resolve(plan)
     .then(plan => plan.assign(extract.output("Fragment"), sample, container))
     .then(plan => plan.choose_items());

}

shark.aq_setup = function() {

  AQ.snap = 16;

  return AQ.OperationType.all_fast(true)
    .then(operation_types => AQ.operation_types = operation_types)
    .then(AQ.User.current)
    .then(user => shark.current_user = user)
    .then(AQ.get_sample_names)  

}

function wait(t, plan) {
  return new Promise(function(resolve,reject) {
    setTimeout(() => resolve(plan), t);
  });
}

describe('Plan_Creation', function() {

  // it("should use successors and predecessors", function(done) {

  //   shark.aq_setup().then(() => {

  //     let unsaved_plan = shark.use_succ_and_pred("Successor/predecessor test");
  //     unsaved_plan.save(shark.current_user).then(saved_plan => {
  //       saved_plan.record_type.should.be.equal("Plan");
  //       saved_plan.name.should.be.equal("Successor/predecessor test");
  //       saved_plan.operations.length.should.be.equal(3);
  //       saved_plan.wires.length.should.be.equal(2);
  //       saved_plan.valid().should.be.equal(false);
  //       saved_plan.destroy().then(done).catch(done);
  //     }).catch(done);

  //   });

  // }).async();

  it("should make a pcr plan", function(done) {

    var sample;

    shark.aq_setup()
        .then(() => AQ.Sample.find_by_name("ADF3 right"))
        .then(s => sample = s)
        .then(() => AQ.ObjectType.find_by_name("Fragment / Gel Slice"))
        .then(container => shark.make_pcr_plan(sample,container))
        .then(plan => plan.save(shark.current_user))
        .then(plan => plan.show_assignments())
        .then(plan => plan.destroy())
        .then(done)
        .catch(done);

  }).async();

});

<% end %>